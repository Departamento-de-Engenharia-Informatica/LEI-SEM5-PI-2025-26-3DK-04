name: Deploy Backend to DEI Environment

on:
  schedule:
    # Configurable schedule - runs daily at 2 AM UTC (adjust as needed)
    - cron: '0 2 * * *'
  push:
    branches:
      - main
      - deploy/*
    paths:
      - 'backend/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  SSH_HOST: vsgate-ssh.dei.isep.ipp.pt
  SSH_PORT: 10592
  DEPLOY_PATH: /root/mainapi
  DOTNET_VERSION: '8.0.x'

jobs:
  test:
    name: Run Backend Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend/MainApi
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore DDDNetCore.csproj

      - name: Build
        run: dotnet build DDDNetCore.csproj --configuration Release --no-restore

      - name: Run Unit Tests
        continue-on-error: true
        run: dotnet test DDDNetCore.csproj --configuration Release --no-build --verbosity normal --logger "trx;LogFileName=test-results.trx" || echo "Tests failed or not found, continuing..."

      - name: Generate test report
        if: always()
        run: |
          mkdir -p ../../test-results
          cp TestResults/*.trx ../../test-results/ 2>/dev/null || echo "No test results found"

      - name: Archive test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-test-results-${{ github.run_number }}
          path: test-results/
          retention-days: 30

  build:
    name: Build and Package Backend
    needs: test
    if: always()
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: backend/MainApi
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore DDDNetCore.csproj

      - name: Publish application
        run: |
          dotnet publish DDDNetCore.csproj \
            --configuration Release \
            --output ./publish \
            --no-restore \
            -p:PublishSingleFile=false \
            -p:PublishTrimmed=false

      - name: Create deployment package
        run: |
          cd publish
          tar -czf ../backend-release.tar.gz .
          cd ..
          echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV
          echo "COMMIT_SHA=${{ github.sha }}" >> $GITHUB_ENV

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-dist-${{ github.run_number }}
          path: backend/MainApi/backend-release.tar.gz

  deploy:
    name: Deploy to DEI Server
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment || 'staging' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: backend-dist-${{ github.run_number }}

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEI_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ env.SSH_PORT }} ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Prepare deployment on DEI server
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            # Create directory structure
            mkdir -p ${{ env.DEPLOY_PATH }}/{releases,shared,logs}
            
            # Create shared configuration directory
            mkdir -p ${{ env.DEPLOY_PATH }}/shared/config
            
            # Create appsettings.json if it doesn't exist
            if [ ! -f ${{ env.DEPLOY_PATH }}/shared/config/appsettings.json ]; then
              cat > ${{ env.DEPLOY_PATH }}/shared/config/appsettings.json << 'EOF'
          {
            "ConnectionStrings": {
              "DefaultConnection": "Host=localhost;Database=DDDSample1DB;Username=postgres;Password=your_password"
            },
            "Logging": {
              "LogLevel": {
                "Default": "Information",
                "Microsoft.AspNetCore": "Warning"
              }
            },
            "AllowedHosts": "*",
            "Kestrel": {
              "Endpoints": {
                "Http": {
                  "Url": "http://0.0.0.0:5000"
                }
              }
            }
          }
          EOF
            fi
            
            # Create systemd service file if it doesn't exist
            if [ ! -f /etc/systemd/system/mainapi.service ]; then
              sudo tee /etc/systemd/system/mainapi.service > /dev/null << 'EOF'
          [Unit]
          Description=MainApi .NET Core Application
          After=network.target

          [Service]
          Type=notify
          User=${{ secrets.DEI_SSH_USER }}
          WorkingDirectory=${{ env.DEPLOY_PATH }}/current
          ExecStart=/usr/bin/dotnet ${{ env.DEPLOY_PATH }}/current/DDDNetCore.dll
          Restart=on-failure
          RestartSec=10
          KillSignal=SIGINT
          SyslogIdentifier=mainapi
          Environment=ASPNETCORE_ENVIRONMENT=Production
          Environment=DOTNET_PRINT_TELEMETRY_MESSAGE=false

          [Install]
          WantedBy=multi-user.target
          EOF
              sudo systemctl daemon-reload
            fi
          ENDSSH

      - name: Deploy to DEI server
        run: |
          RELEASE_DIR="${{ env.DEPLOY_PATH }}/releases/${{ github.run_number }}"
          
          # Create release directory
          ssh -p ${{ env.SSH_PORT }} ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }} \
            "mkdir -p ${RELEASE_DIR}"

          # Upload build artifact
          scp -P ${{ env.SSH_PORT }} backend-release.tar.gz \
            ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }}:${RELEASE_DIR}/

          # Extract and setup
          ssh -p ${{ env.SSH_PORT }} ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }} << ENDSSH
            cd ${RELEASE_DIR}
            tar -xzf backend-release.tar.gz
            rm backend-release.tar.gz
            
            # Link shared configuration
            ln -sf ${{ env.DEPLOY_PATH }}/shared/config/appsettings.json appsettings.json
            
            # Make executable
            chmod +x DDDNetCore.dll
            
            # Stop the service if running
            sudo systemctl stop mainapi || true
            
            # Create symlink to current release
            ln -sfn ${RELEASE_DIR} ${{ env.DEPLOY_PATH }}/current
            
            # Start the service
            sudo systemctl start mainapi
            sudo systemctl enable mainapi
            
            # Wait for service to start
            sleep 5
            
            # Check service status
            sudo systemctl status mainapi --no-pager || true
            
            # Cleanup old releases (keep last 5)
            cd ${{ env.DEPLOY_PATH }}/releases
            ls -t | tail -n +6 | xargs -r rm -rf
          ENDSSH

      - name: Create deployment log
        run: |
          cat > deployment-log.json << EOF
          {
            "deployment_id": "${{ github.run_number }}",
            "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
            "commit_sha": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "triggered_by": "${{ github.actor }}",
            "environment": "${{ github.event.inputs.environment || 'staging' }}",
            "component": "backend"
          }
          EOF
          
          scp -P ${{ env.SSH_PORT }} deployment-log.json \
            ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }}:${{ env.DEPLOY_PATH }}/logs/deployment-${{ github.run_number }}.json

  validate:
    name: Validate Backend Deployment
    needs: deploy
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEI_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -p ${{ env.SSH_PORT }} ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Check service status
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            # Check if service is running
            if ! sudo systemctl is-active --quiet mainapi; then
              echo "ERROR: MainApi service is not running"
              sudo journalctl -u mainapi -n 50 --no-pager
              exit 1
            fi
            
            echo "MainApi service is running"
            sudo systemctl status mainapi --no-pager
          ENDSSH

      - name: Health check endpoint
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            # Wait for application to be ready
            for i in {1..30}; do
              if curl -f -s http://localhost:5000/api/health > /dev/null 2>&1 || \
                 curl -f -s http://localhost:5000/swagger/index.html > /dev/null 2>&1; then
                echo "Application is responding"
                exit 0
              fi
              echo "Waiting for application to respond... ($i/30)"
              sleep 2
            done
            
            echo "ERROR: Application did not respond in time"
            sudo journalctl -u mainapi -n 100 --no-pager
            exit 1
          ENDSSH

      - name: Run smoke tests
        run: |
          ssh -p ${{ env.SSH_PORT }} ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }} << 'ENDSSH'
            # Test Swagger endpoint
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/swagger/index.html)
            if [ "$HTTP_CODE" != "200" ]; then
              echo "ERROR: Swagger endpoint returned $HTTP_CODE"
              exit 1
            fi
            echo "Swagger endpoint is accessible"
            
            # Check logs for errors
            if sudo journalctl -u mainapi -n 50 --no-pager | grep -i "error\|exception\|fatal"; then
              echo "WARNING: Errors found in logs"
            fi
          ENDSSH

      - name: Archive validation results
        if: always()
        run: |
          mkdir -p validation-results
          ssh -p ${{ env.SSH_PORT }} ${{ secrets.DEI_SSH_USER }}@${{ env.SSH_HOST }} \
            "sudo journalctl -u mainapi -n 100 --no-pager" > validation-results/service-logs.txt || true
          echo "Validation completed at $(date)" > validation-results/summary.txt

      - name: Upload validation results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-validation-results-${{ github.run_number }}
          path: validation-results/
          retention-days: 30

  notify:
    name: Send Deployment Notification
    needs: [deploy, validate]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Check deployment status
        run: |
          if [ "${{ needs.validate.result }}" == "success" ]; then
            echo "✅ Deployment successful!"
          else
            echo "❌ Deployment failed!"
            exit 1
          fi